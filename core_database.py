# core_database.py
"""
core_database.py - Datab√°ze jazzov√Ωch standard≈Ø a jejich progres√≠.
VYLEP≈†ENO: Bezpeƒçn√© naƒç√≠t√°n√≠ s try-catch a podporou v√≠ce JSON soubor≈Ø.
"""

import logging
import json
import os
from typing import List, Dict, Optional, Any
from functools import lru_cache

logger = logging.getLogger(__name__)


class JazzStandardsDatabase:
    """
    Datab√°ze jazzov√Ωch standard≈Ø a jejich progres√≠.
    VYLEP≈†ENO: Bezpeƒçn√© naƒç√≠t√°n√≠ s mo≈ænost√≠ mergov√°n√≠ v√≠ce JSON soubor≈Ø.
    """

    # Konfigurace datab√°zov√Ωch soubor≈Ø - lze upravit podle pot≈ôeby
    DATABASE_FILES = [
        'database.json',  # Hlavn√≠ datab√°ze
        'database_classics.json',  # Klasick√© standardy (voliteln√Ω)
        'database_modern.json',  # Modern√≠ jazz (voliteln√Ω)
        'database_exercises.json'  # Cviƒçen√≠ a progrese (voliteln√Ω)
    ]

    # Inicializace pr√°zdn√© datab√°ze
    JAZZ_STANDARDS = {}
    TRANSPOSED_STANDARDS = {}

    # Flag pro sledov√°n√≠ stavu inicializace
    _database_loaded = False
    _load_errors = []

    @classmethod
    def _load_database_safely(cls) -> Dict[str, Any]:
        """
        Bezpeƒçn√© naƒçten√≠ datab√°ze z jednoho nebo v√≠ce JSON soubor≈Ø.

        Returns:
            Dict[str, Any]: Slouƒçen√° datab√°ze ze v≈°ech dostupn√Ωch soubor≈Ø
        """
        merged_database = {}
        loaded_files = []
        errors = []

        logger.info(f"Naƒç√≠t√°m datab√°zi ze soubor≈Ø: {cls.DATABASE_FILES}")

        for filename in cls.DATABASE_FILES:
            try:
                if not os.path.exists(filename):
                    logger.debug(f"Soubor {filename} neexistuje, p≈ôeskakujƒô")
                    continue

                logger.debug(f"Pokus o naƒçten√≠ souboru: {filename}")

                with open(filename, 'r', encoding='utf-8') as f:
                    file_data = json.load(f)

                # Validace ≈æe se jedn√° o slovn√≠k
                if not isinstance(file_data, dict):
                    raise ValueError(f"Soubor {filename} neobsahuje slovn√≠k na root √∫rovni")

                # Kontrola koliz√≠ n√°zv≈Ø p√≠sn√≠
                collisions = set(merged_database.keys()) & set(file_data.keys())
                if collisions:
                    logger.warning(f"Kolize n√°zv≈Ø p√≠sn√≠ v {filename}: {collisions} - p≈ôep√≠≈°u p≈Øvodn√≠")

                # Merge do hlavn√≠ datab√°ze
                merged_database.update(file_data)
                loaded_files.append(filename)

                logger.info(f"‚úÖ Naƒçten {filename}: {len(file_data)} p√≠sn√≠")

            except FileNotFoundError:
                logger.debug(f"Soubor {filename} nenalezen")

            except json.JSONDecodeError as e:
                error_msg = f"Chyba JSON form√°tu v {filename}: {e}"
                logger.error(error_msg)
                errors.append(error_msg)

            except ValueError as e:
                error_msg = f"Chyba struktury dat v {filename}: {e}"
                logger.error(error_msg)
                errors.append(error_msg)

            except Exception as e:
                error_msg = f"Neoƒçek√°van√° chyba p≈ôi naƒç√≠t√°n√≠ {filename}: {e}"
                logger.error(error_msg)
                errors.append(error_msg)

        # V√Ωsledek naƒç√≠t√°n√≠
        total_songs = len(merged_database)
        if total_songs > 0:
            logger.info(f"üéµ Datab√°ze √∫spƒõ≈°nƒõ naƒçtena: {total_songs} p√≠sn√≠ ze soubor≈Ø: {loaded_files}")
        else:
            logger.warning("‚ö†Ô∏è ≈Ω√°dn√° datab√°ze nebyla naƒçtena - pou≈æiji fallback")
            merged_database = cls._get_fallback_database()

        if errors:
            logger.warning(f"Chyby p≈ôi naƒç√≠t√°n√≠: {len(errors)} probl√©m≈Ø")
            cls._load_errors = errors

        return merged_database

    @classmethod
    def _get_fallback_database(cls) -> Dict[str, Any]:
        """
        Z√°kladn√≠ fallback datab√°ze pro p≈ô√≠pad selh√°n√≠ naƒç√≠t√°n√≠.
        Obsahuje minim√°ln√≠ sadu progres√≠ pro testov√°n√≠.

        Returns:
            Dict[str, Any]: Minim√°ln√≠ datab√°ze s nƒõkolika z√°kladn√≠mi progresemi
        """
        logger.info("Pou≈æ√≠v√°m fallback datab√°zi")

        return {
            "ii-V-I Dur z√°kladn√≠": {
                "key": "C",
                "difficulty": "Easy",
                "progressions": [
                    {
                        "chords": ["Dm7", "G7", "Cmaj7"],
                        "description": "Z√°kladn√≠ ii-V-I v C dur"
                    }
                ]
            },
            "ii-V-I Moll z√°kladn√≠": {
                "key": "Cm",
                "difficulty": "Easy",
                "progressions": [
                    {
                        "chords": ["Dm7b5", "G7", "Cm7"],
                        "description": "Z√°kladn√≠ ii√ò-V-i v C moll"
                    }
                ]
            },
            "Blues C": {
                "key": "C",
                "difficulty": "Easy",
                "progressions": [
                    {
                        "chords": ["C7", "F7", "C7", "G7", "F7", "C7"],
                        "description": "Z√°kladn√≠ bluesov√° progrese"
                    }
                ]
            }
        }

    @classmethod
    def _ensure_database_loaded(cls) -> None:
        """
        Zajist√≠, ≈æe datab√°ze je naƒçten√°. Vol√° se automaticky p≈ôi prvn√≠m p≈ô√≠stupu.
        """
        if not cls._database_loaded:
            logger.debug("Inicializuji datab√°zi...")
            cls.JAZZ_STANDARDS = cls._load_database_safely()
            cls._database_loaded = True

    @classmethod
    def _initialize_transposed_standards(cls):
        """
        Vytvo≈ô√≠ transponovan√© verze standard≈Ø pro v≈°ech 11 transpozic.
        OPRAVENO: Pou≈æ√≠v√° centr√°ln√≠ core_music_theory.py a bezpeƒçn√© naƒç√≠t√°n√≠.
        """
        cls._ensure_database_loaded()  # Zajist√≠ naƒçten√≠ datab√°ze

        if cls.TRANSPOSED_STANDARDS:  # U≈æ inicializov√°no
            return

        # OPRAVA: Import z centr√°ln√≠ho modulu
        try:
            from core_music_theory import transpose_note, transpose_chord
        except ImportError as e:
            logger.error(f"Chyba importu transpose funkc√≠ z core_music_theory: {e}")
            return

        transposed_count = 0
        for song_name, song_data in cls.JAZZ_STANDARDS.items():
            try:
                original_key = song_data.get("key", "C")  # Bezpeƒçn√Ω p≈ô√≠stup

                if not original_key:
                    logger.warning(f"P√≠se≈à {song_name} nem√° definovan√Ω key, p≈ôeskakuji transpozice")
                    continue

                for semitones in range(1, 12):  # 1 a≈æ 11
                    try:
                        # OPRAVA: Rozli≈°en√≠ mezi jednoduchou notou a akordem
                        if len(original_key) == 1 or (len(original_key) == 2 and original_key[1] in ['#', 'b']):
                            # Jednoduch√° nota
                            transposed_key = transpose_note(original_key, semitones)
                        else:
                            # Slo≈æen√Ω akord
                            transposed_key = transpose_chord(original_key, semitones)

                        # Bezpeƒçn√Ω p≈ô√≠stup k progres√≠m
                        original_progressions = song_data.get("progressions", [])
                        transposed_progressions = []

                        for prog in original_progressions:
                            if not isinstance(prog, dict) or "chords" not in prog:
                                logger.warning(f"Neplatn√° progrese v {song_name}, p≈ôeskakuji")
                                continue

                            transposed_chords = [transpose_chord(chord, semitones) for chord in prog["chords"]]
                            transposed_prog = prog.copy()
                            transposed_prog["chords"] = transposed_chords
                            transposed_progressions.append(transposed_prog)

                        transposed_song = song_data.copy()
                        transposed_song["key"] = transposed_key
                        transposed_song["transposed_by"] = semitones
                        transposed_song["original_key"] = original_key
                        transposed_song["progressions"] = transposed_progressions

                        transposed_name = f"{song_name}_trans_{semitones}"
                        cls.TRANSPOSED_STANDARDS[transposed_name] = transposed_song
                        transposed_count += 1

                    except Exception as e:
                        logger.warning(f"Chyba p≈ôi transpozici {song_name} o {semitones} p≈Ølt√≥n≈Ø: {e}")
                        continue

            except Exception as e:
                logger.error(f"Chyba p≈ôi zpracov√°n√≠ p√≠snƒõ {song_name}: {e}")
                continue

        logger.info(f"Inicializov√°no {transposed_count} transponovan√Ωch standard≈Ø")

    @classmethod
    def get_song_info(cls, song_name: str) -> Optional[Dict]:
        """
        Z√≠sk√° kompletn√≠ informace o p√≠sni.

        Args:
            song_name: N√°zev p√≠snƒõ

        Returns:
            Optional[Dict]: Informace o p√≠sni nebo None pokud nen√≠ nalezena
        """
        cls._ensure_database_loaded()
        cls._initialize_transposed_standards()  # Zaji≈°tƒõn√≠ inicializace
        return cls.JAZZ_STANDARDS.get(song_name) or cls.TRANSPOSED_STANDARDS.get(song_name)

    @classmethod
    def get_all_songs(cls) -> List[str]:
        """
        Vr√°t√≠ seznam v≈°ech p√≠sn√≠ v datab√°zi.

        Returns:
            List[str]: Se≈ôazen√Ω seznam n√°zv≈Ø p√≠sn√≠
        """
        cls._ensure_database_loaded()
        cls._initialize_transposed_standards()
        return sorted(list(cls.JAZZ_STANDARDS.keys()) + list(cls.TRANSPOSED_STANDARDS.keys()))

    @classmethod
    @lru_cache(maxsize=128)
    def find_progressions_by_chord(cls, base_note: str, chord_type: str) -> List[Dict[str, Any]]:
        """
        Hled√° progrese, kter√© obsahuj√≠ dan√Ω akord, vƒçetnƒõ transponovan√Ωch verz√≠.
        OPRAVENO: P≈ôid√°no debugging pro sledov√°n√≠ probl√©m≈Ø a bezpeƒçn√© naƒç√≠t√°n√≠.

        Args:
            base_note: Z√°kladn√≠ nota akordu
            chord_type: Typ akordu

        Returns:
            List[Dict[str, Any]]: Seznam nalezen√Ωch progres√≠ s metadaty
        """
        cls._ensure_database_loaded()
        cls._initialize_transposed_standards()
        target_chord = f"{base_note}{chord_type}"
        results = []

        logger.debug(f"Hled√°m progrese pro akord: {target_chord}")

        try:
            # Nejd≈ô√≠v prohledat origin√°ly
            for song_name, song_data in cls.JAZZ_STANDARDS.items():
                if not isinstance(song_data, dict):
                    continue

                progressions = song_data.get("progressions", [])
                for prog in progressions:
                    if not isinstance(prog, dict) or "chords" not in prog:
                        continue

                    if any(c.upper() == target_chord.upper() for c in prog["chords"]):
                        prog_copy = prog.copy()
                        prog_copy['song'] = song_name
                        prog_copy['transposed_by'] = 0  # Oznaƒçen√≠ jako origin√°l
                        prog_copy['transposed_key'] = None
                        prog_copy['original_key'] = song_data.get("key", "Unknown")
                        results.append(prog_copy)
                        logger.debug(f"Nalezena origin√°ln√≠ progrese v {song_name}: {prog['chords']}")

            # Pak transponovan√©
            for song_name, song_data in cls.TRANSPOSED_STANDARDS.items():
                if not isinstance(song_data, dict):
                    continue

                progressions = song_data.get("progressions", [])
                for prog in progressions:
                    if not isinstance(prog, dict) or "chords" not in prog:
                        continue

                    if any(c.upper() == target_chord.upper() for c in prog["chords"]):
                        prog_copy = prog.copy()
                        prog_copy['song'] = song_name.split("_trans_")[0]  # P≈Øvodn√≠ n√°zev p√≠snƒõ
                        prog_copy['transposed_by'] = song_data.get("transposed_by", 0)
                        prog_copy['transposed_key'] = song_data.get("key", "Unknown")
                        prog_copy['original_key'] = song_data.get("original_key", "Unknown")
                        results.append(prog_copy)
                        logger.debug(
                            f"Nalezena transponovan√° progrese v {song_name}: {prog['chords']} "
                            f"(transpozice +{song_data.get('transposed_by', 0)})")

        except Exception as e:
            logger.error(f"Chyba p≈ôi hled√°n√≠ progres√≠ pro {target_chord}: {e}")

        logger.info(f"Nalezeno {len(results)} progres√≠ pro akord {target_chord} (vƒçetnƒõ transpozic)")
        return results

    @classmethod
    def get_database_info(cls) -> Dict[str, Any]:
        """
        Vr√°t√≠ informace o stavu datab√°ze pro debugging a monitoring.

        Returns:
            Dict[str, Any]: Informace o datab√°zi
        """
        cls._ensure_database_loaded()
        cls._initialize_transposed_standards()

        return {
            "database_loaded": cls._database_loaded,
            "original_songs_count": len(cls.JAZZ_STANDARDS),
            "transposed_songs_count": len(cls.TRANSPOSED_STANDARDS),
            "total_songs": len(cls.JAZZ_STANDARDS) + len(cls.TRANSPOSED_STANDARDS),
            "load_errors_count": len(cls._load_errors),
            "load_errors": cls._load_errors.copy(),
            "configured_files": cls.DATABASE_FILES.copy()
        }

    @classmethod
    def reload_database(cls) -> bool:
        """
        Znovu naƒçte datab√°zi ze soubor≈Ø. U≈æiteƒçn√© pro v√Ωvoj nebo aktualizace.

        Returns:
            bool: True pokud reload probƒõhl √∫spƒõ≈°nƒõ
        """
        logger.info("Reload datab√°ze...")

        try:
            # Reset stav≈Ø
            cls._database_loaded = False
            cls._load_errors.clear()
            cls.JAZZ_STANDARDS.clear()
            cls.TRANSPOSED_STANDARDS.clear()

            # Vyƒçisti cache
            cls.find_progressions_by_chord.cache_clear()

            # Znovu naƒçti
            cls._ensure_database_loaded()
            cls._initialize_transposed_standards()

            logger.info("‚úÖ Reload datab√°ze dokonƒçen")
            return True

        except Exception as e:
            logger.error(f"‚ùå Chyba p≈ôi reload datab√°ze: {e}")
            return False
